<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>arts_three</title>
    <url>/2019/11/09/arts-three/</url>
    <content><![CDATA[<blockquote>
<p>ARTS</p>
<blockquote>
<p>A(Algorithm): 完成一道leetcode算法题，顺带重新熟悉数据结构和算法；<br>R(Review): 阅读相关/有兴趣的英文技术文章，主要是为了学习英文；<br>T(Tips): 学习至少一个技术技巧，主要为了总结和归纳在日常工作中遇到的知识点；<br>S(Share): 编写一篇文章，让自己习惯输出；</p>
</blockquote>
</blockquote>
<h2 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h2><p>第三周来看看栈吧，经典的栈题目：<a href="https://leetcode.com/problems/valid-parentheses/" target="_blank" rel="noopener">有效的括号LC20</a></p>
<h4 id="解题："><a href="#解题：" class="headerlink" title="解题："></a>解题：</h4><p>简单题，提前声明存在的几组括号，由于题目要求括号必需按照正确的顺序闭合，迭代字符串：</p>
<p>当前字符为起始括号时，在栈中放入对应的闭合括号。</p>
<p>当期字符为闭合括号时，与栈内最后置入的闭合扩号做对比，栈为空或不一致时代表非法。</p>
<p>若字符迭代结束后栈内存留有元素，说明起始括号数大于闭合括号数，字符非法。</p>
<pre><code>public boolean isValid(String s) {
    //提前声明存在的几个括号的对应关系
    Map&lt;Character, Character&gt; mapping = new HashMap&lt;&gt;(3);
    mapping.put(&apos;[&apos;, &apos;]&apos;);
    mapping.put(&apos;(&apos;, &apos;)&apos;);
    mapping.put(&apos;{&apos;, &apos;}&apos;);

    Stack&lt;Character&gt; stack = new Stack&lt;&gt;();
    for (int i = 0; i &lt; s.length(); i++) {
        Character c = s.charAt(i);
        if (mapping.containsKey(c)) {
            //当前符号为起始括号 在栈中放入对应的结束符号
            stack.push(mapping.get(c));
        } else {
            //当前符号为闭合括号，与栈中预存的对应符号作对不 栈内无元素或不一致 提前返回非法判断
            if (stack.isEmpty() || !c.equals(stack.pop())) {
                return false;
            }
        }
    }
    return stack.isEmpty();
}</code></pre><h2 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h2><p><a href="https://blog.codinghorror.com/an-exercise-program-for-the-fat-web/" target="_blank" rel="noopener">An Exercise Program for the Fat Web</a> emm这标题的翻译有点拗口啊，一个用于解决网站肥胖化的锻炼程序。</p>
<p>这里有一篇15年的某个会议上发布的<a href="https://idlewords.com/talks/website_obesity.htm" target="_blank" rel="noopener">文章</a> 如果你没有时间阅读它，那么我们可以来看简单的结果</p>
<blockquote>
<p>This is a screenshot from an NPR article discussing the rising use of ad blockers. The page is 12 megabytes in size in a stock web browser. The same article with basic ad blocking turned on is 1 megabyte.</p>
<p>这是NPR文章的屏幕截图，其中讨论了广告拦截器的使用不断增加。在网页浏览器中，该页面的大小为12 MB。开启基本广告屏蔽功能的同一篇文章为1 MB。</p>
</blockquote>
<p><strong>网站肥胖化的原因</strong></p>
<ul>
<li>不断增多的广告 Unlimited, unfettered ad </li>
</ul>
<p><strong>解决广告</strong></p>
<p>此前我们有着非常方便的手段 浏览器提供了非常多的广告拦截插件，你只需要挑选一个即可</p>
<p>然而<a href="https://ww.9to5google.com/2019/05/29/chrome-ad-blocking-enterprise-manifest-v3/" target="_blank" rel="noopener">Google将现代广告拦截Chrome扩展程序限制为企业用户</a> ，那么危机来了，脱离了广告拦截器我们以后改怎么办。</p>
<p>这里推荐了一套基于树莓派的dns拦截方案 <a href="https://pi-hole.net/" target="_blank" rel="noopener">Pi-hole</a></p>
<p>首先你需要以下物品以及一个小时的配置时间 <a href="https://www.smarthomebeginner.com/pi-hole-setup-guide/" target="_blank" rel="noopener">指南</a>：</p>
<ul>
<li>a Raspberry Pi 3b+ kit $59</li>
<li>a quality 32GB SD card $9</li>
<li>an ethernet cable</li>
</ul>
<p>如果你在路由器上禁用了D​​HCP，并让Pi-Hole成为DHCP，那么局域网内每台设备都将自动获得基于DNS的广告拦截。</p>
<p>当然我们暂时还不需要这方案，但是如果<em>广告拦截插件</em>真的失效了，这可能就是下一个避风港。</p>
<h2 id="Tip-amp-Share"><a href="#Tip-amp-Share" class="headerlink" title="Tip&amp;Share"></a>Tip&amp;Share</h2><p>这期就总结下栈的相关知识点</p>
<h4 id="如何理解“栈”？"><a href="#如何理解“栈”？" class="headerlink" title="如何理解“栈”？"></a>如何理解“栈”？</h4><blockquote>
<p>后进者先出，先进者后出，这就是典型的“栈”结构。</p>
<p>简单来看 它可以看做一条笔直向下的没有终点的单向地道，你进来方便，抓住梯子往下行进，但是如果你想出去，你必需要求并等待你上方的所有人都先出去，并让路给你。</p>
</blockquote>
<p>从栈的操作特性上来看，<strong>栈是一种“操作受限”的线性表</strong>，你只有两个操作 置入栈顶元素，取出栈顶元素。</p>
<p>就原理来说 链表和数组都可以作为栈，用数组实现的栈，称为<strong>顺序栈</strong>，用链表实现的栈，称为<strong>链式栈</strong>。</p>
<p>两者的操作时间复杂度均为O(1)。顺序栈需要提前声明大小，若超出，则需要额外的扩容操作；链式栈不需要扩容但是需要额外存储对应的指针域。</p>
<h4 id="括号匹配"><a href="#括号匹配" class="headerlink" title="括号匹配"></a>括号匹配</h4><p>如同上面的 LC20 所示 给定包含<code>括号（）、中括号[]、花括号{}</code>三种字符的字符创，只要能成功闭合就是一个合法字符串，合法串：”()” “()[]{}” “” 非法串：”(]””({)]”， 完整的文字版解题思路：</p>
<p>声明一个栈用于存入字符 ，从左到右依次扫描给定的字符串。当扫描到左括号，由于需要正确闭合则字符串后续必定存在对应的右括号，所以把一个对应的右括号置入栈中；当扫描到右括号，由于需要正确并且顺序闭合，当前栈顶元素必定与当前右括号匹配，若栈为空或栈顶元素不匹配时，说明字符串非法。</p>
<p>扫描结束时，若栈内有残留元素 说明起始括号多余闭合括号，字符非法。若栈为空，说明所有括号闭合成功或字符串为空串，均为合法。</p>
<h4 id="拓展：同样的“栈”"><a href="#拓展：同样的“栈”" class="headerlink" title="拓展：同样的“栈”"></a>拓展：同样的“栈”</h4><blockquote>
<p>我们都知道，JVM 内存管理中有个“堆栈”的概念。栈内存用来存储局部变量和方法调用，堆内存用来存储 Java 中的对象。那 JVM 里面的“栈”跟我们这里说的“栈”是不是一回事呢？如果不是，那它为什么又叫作“栈”呢？</p>
</blockquote>
<p>两者的栈含义不同，上面所说的栈是抽象意义的数据存储结构，而JVM中的栈则是用于存储临时变量的存储区域，但两者都符合先进后出的概念。</p>
<p><strong>根据oracle关于栈和栈帧的描述</strong></p>
<blockquote>
<p>每个JVM线程拥有一个私有的 Java虚拟机栈，创建线程的同时栈也被创建。一个JVM栈由许多帧组成，称之为”栈帧”。</p>
</blockquote>
<blockquote>
<p>栈帧由三部分组成：局部变量表、操作数栈以及帧数据。</p>
</blockquote>
<p>当一个新的线程创建时，JVM会为这个线程创建一个新的Stack。一个Java Stack在一个个独立的栈帧中存储了线程的状态。JVM只会在Java Stack中做两个操作：push 和 pop.</p>
<p>一个线程当前正在执行的方法称之为线程的 当前方法，当前方法对应的栈帧称为 当前帧，当前方法所属的类称为 当前类，当前类的常量池称为 当前常量池。 在执行一个方法时，JVM会保存当前类和当前常量池的轨迹。当JVM执行 需要操作栈帧中数据的指令时，JVM会在当前栈帧进行处理。</p>
<p>当一个线程执行一个Java方法时，JVM将创建一个新的栈帧并且把它push到栈顶。此时新的栈帧就变成了当前栈帧，方法执行时，使用栈帧来存储参数、局部变量、中间指令以及其他数据。</p>
]]></content>
  </entry>
  <entry>
    <title>arts_two</title>
    <url>/2019/11/02/arts-two/</url>
    <content><![CDATA[<blockquote>
<p>ARTS</p>
<blockquote>
<p>A(Algorithm): 完成一道leetcode算法题，顺带重新熟悉数据结构和算法；<br>R(Review): 阅读相关/有兴趣的英文技术文章，主要是为了学习英文；<br>T(Tips): 学习至少一个技术技巧，主要为了总结和归纳在日常工作中遇到的知识点；<br>S(Share): 编写一篇文章，让自己习惯输出；</p>
</blockquote>
</blockquote>
<h2 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h2><p>第二周继续链表练习：<a href="https://leetcode.com/problems/middle-of-the-linked-list/" target="_blank" rel="noopener">求链表的中间结点LC876</a></p>
<h4 id="解题："><a href="#解题：" class="headerlink" title="解题："></a>解题：</h4><p>由快慢指针获取中点位置</p>
<p>fast slow 节点同时从前置dumy节点出发。</p>
<p>fast==null 到达奇数链表尾节点，即长度为2n-1，slow节点为n,正确;</p>
<p>fast.next==null 到达偶数链表的尾节点的前一节点，即长度为2n，slow节点为n，但正确节点应该为n+1;</p>
<p>简单题。。但是由于读题错误导致解题错误。。</p>
<p>题目说明给定了一个带head节点的链表。。误以为是一个类似dummy节点的标记节点</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">middleNode</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    ListNode dummy = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">    dummy.next = head;</span><br><span class="line">    ListNode fast = dummy;</span><br><span class="line">    ListNode slow = dummy;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (fast == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> slow.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="优化："><a href="#优化：" class="headerlink" title="优化："></a>优化：</h4><p>原思路一是根据存在前置节点的情况预读，去除前置节点，从首节点出发：</p>
<p>fast==null时 即链表为偶数链表，长度为2n,同时slow节点同时处于n+1节点即符合双中点的后者，正确。</p>
<p>fast.nest==null时，即链表为奇数链表 长度为2n+1，slow节点为n+1，正确。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> ListNode <span class="title">middleNode</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">         ListNode fast = head;</span><br><span class="line">         ListNode slow = head;</span><br><span class="line">         <span class="keyword">while</span> (fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">             fast = fast.next.next;</span><br><span class="line">             slow = slow.next;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h2><p><a href="https://forge.medium.com/3-steps-to-beating-imposter-syndrome-78e8e7e3f4c3" target="_blank" rel="noopener">三步击败冒名顶替综合征</a></p>
<p>说服自己才是坚持一件事的最基础起点，WHW：为什么我们要下笔，我们要怎么分享，我们要分享什么。</p>
<p>嘛，刚好在<code>medium</code>的首页看到这篇的推荐，作为第二篇也很适合，毕竟上一篇也有说道冒名顶替综合征。</p>
<blockquote>
<p>impostor syndrome is rarely a sign that you’re going down the wrong path. Most of the time, it’s simply a defense mechanism against failure and disappointment. When we try to talk ourselves out of pursuing our goals, when we try to convince ourselves that our work isn’t important, we’re avoiding whatever it is we need to do. <em>We don’t want to falter, so we never start. And when we never start, we never succeed</em>.</p>
<p>冒名顶替综合征很少表示你走错了路。大多数情况下，它只是针对失败和失望的防御机制。我们不想动摇，所以我们不回去开始。当我们不开始，我们也就永远不会成功。</p>
</blockquote>
<ol>
<li><strong>承认这种感觉</strong> 你如果怕自己不太适合或者害怕尝试，这是正常的。</li>
<li><strong>检查你的动机</strong> 找到自己的why</li>
<li><strong>把自己当做求知者</strong> 承认并找到你不擅长的内容，然后去学习。不是为了假装自己的博学，仅仅只是为了自己的好奇心</li>
</ol>
<blockquote>
<p>Treat your work as one big experiment; an opportunity to learn. Because in the end, that’s exactly what it is.</p>
<p>将您的工作视为一项重大实验；一个学习的机会。因为最终，这就是事实。</p>
</blockquote>
<h2 id="Tip-amp-Share"><a href="#Tip-amp-Share" class="headerlink" title="Tip&amp;Share"></a>Tip&amp;Share</h2><p>上面提到了一下 WHW 那么这次就顺带简单说一下 黄金圈吧。</p>
<p>这是由作家 西门·奈克（Simon O. Sinek）提出一个为了更好地卖出自己的产品的营销法则，但是经过时间实践，慢慢地人们发现它其实适用于各种情况下。当然这里主要是说黄金圈法则由内到外的用法，即（WHY-HOW-WHAT）。<br><img src="https://blog-1300448206.cos.ap-shanghai.myqcloud.com/pasted%20image%200.png" alt="WHY-HOW-WHAT"></p>
<p>在生活中每个人每个公司都明白自己是做什么的（what），部分领导也会明确知道一个任务要怎么完成（how），但是只有少数人有着为什么做这件事（why）的觉悟。拿到任务，简单分析怎么做，开始下手，这是大部分人的常态，我们不会去考虑这件事的缘由。所以做下以下的思考：你的目的是什么？你这么做的原因是什么？你怀着怎么样的理想？</p>
<p>黄金圈的出发点和中心是“为什么<code>WHY</code>”的问题，WHY代表着我们的目的和理念。</p>
<p>我为什么要写博客？为了习惯输出？不够。为了学习？不够。为了结交部分朋友？不够。因为恐慌？部分正确。继续思考ing.</p>
<p>同时我们有了目标，我们要怎么做（how）这件事，具体计划、临时计划、怎么安排等等，这是我们的具体操作方式和措施。</p>
<p>我要怎么写博客？暂时不太清楚，先按照arts的标准来慢慢习惯，再找到自己习惯/喜欢的方式。</p>
<p>那么经由以上两者之后所造就的结果就是什么（what），它是我们的经历以及成果。</p>
<p>我要写些什么？应该是我学到了什么。</p>
<p>这是一个追求长期目标的不二法则，当然前提还是坚持。</p>
]]></content>
  </entry>
  <entry>
    <title>arts_one</title>
    <url>/2019/10/26/arts-one/</url>
    <content><![CDATA[<blockquote>
<p>ARTS</p>
<blockquote>
<p>A(Algorithm): 完成一道leetcode算法题，顺带重新熟悉数据结构和算法；<br>R(Review): 阅读相关/有兴趣的英文技术文章，主要是为了学习英文；<br>T(Tips): 学习至少一个技术技巧，主要为了总结和归纳在日常工作中遇到的知识点；<br>S(Share): 编写一篇文章，让自己习惯输出；</p>
</blockquote>
</blockquote>
<h2 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h2><p>第一周先熟悉下数据结构吧，随便挑了道链表的基础题：<a href="https://leetcode.com/problems/merge-two-sorted-lists/" target="_blank" rel="noopener">有序链表合并LC21</a></p>
<h4 id="递归："><a href="#递归：" class="headerlink" title="递归："></a>递归：</h4><p>由于题目给与的两个入参明确为有序链表，排除空链表以及尾节点的情况下，只需要简单比较当前节点大小并递归下一节点即可，时间空间复杂度均为O(n)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123;</span><br><span class="line">       if (Objects.isNull(l1) &amp;&amp; Objects.isNull(l2)) &#123;</span><br><span class="line">           return null;</span><br><span class="line">       &#125; else if (Objects.isNull(l1)) &#123;</span><br><span class="line">           return l2;</span><br><span class="line">       &#125; else if (Objects.isNull(l2)) &#123;</span><br><span class="line">           return l1;</span><br><span class="line">       &#125;</span><br><span class="line">       ListNode result;</span><br><span class="line">       if (l1.val &lt;= l2.val) &#123;</span><br><span class="line">           result = l1;</span><br><span class="line">           result.next = mergeTwoLists(l1.next, l2);</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           result = l2;</span><br><span class="line">           result.next = mergeTwoLists(l1, l2.next);</span><br><span class="line">       &#125;</span><br><span class="line">       return result;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>


<h4 id="迭代："><a href="#迭代：" class="headerlink" title="迭代："></a>迭代：</h4><p>手动建立一个新的结果链表节点result，同时放置标记prev。循环迭代 l1、l2节点 并比较大小 小的设为标记节点的next节点，重置标记节点为结果链表的最后一个节点，直到l1、l2链表其一到达null节点为止，排除已结束的链表并把另一链表的剩余项加入结果链表</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123;</span><br><span class="line">       ListNode result = new ListNode(-1);</span><br><span class="line">       ListNode prev = result;</span><br><span class="line">       while (l1 != null &amp;&amp; l2 != null) &#123;</span><br><span class="line">           if (l1.val &lt;= l2.val) &#123;</span><br><span class="line">               prev.next = l1;</span><br><span class="line">               l1 = l1.next;</span><br><span class="line">           &#125; else &#123;</span><br><span class="line">               prev.next = l2;</span><br><span class="line">               l2 = l2.next;</span><br><span class="line">           &#125;</span><br><span class="line">           prev = prev.next;</span><br><span class="line">       &#125;</span><br><span class="line">       prev.next = l1 == null ? l2 : l1;</span><br><span class="line">       return result.next;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h2 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h2><p><a href="https://towardsdatascience.com/great-developers-never-stop-learning-77b9ce867eac" target="_blank" rel="noopener">一名优秀程序员应该持续学习</a><br>找着review的文章刚好找到一篇歪果仁妹子写的持续学习，刚好符合开篇，就它了。</p>
<blockquote>
<p>Although it is impossible to stay up to speed with everything in this rapidly changing world of I.T., we need to choose a few areas that interest us (whether these areas are related to our current job, or the one we want in the future) and carve time out to up-skill.</p>
<p>在这个瞬息万变的IT世界我们不可能学习所有新技术，所以我们需要选择一部分与自身工作相关或者与自身规划相关的部分然后抽出时间来提升这些技能。</p>
</blockquote>
<ol>
<li>阅读的艺术（书籍、博客、推特（当然对我们来说是微博、微信…））</li>
<li>从热爱阅读到热爱写作 （要知道学会一件事最有效的方法就是教别人学会）</li>
<li>播客的碎片学习 （你可以在做饭、工作、无聊时多线程地学习）</li>
<li>参与在线课程 （优秀的教学视频是平衡理论和实践的完美选择）</li>
<li>实践出真知 （概念验证（POC）、宠物项目、开源项目、在线社区、黑客马拉松）</li>
<li>结对编程（代码审查）</li>
<li>社交活动（参加行业活动、加微信群、建立自己的社交网络…）</li>
</ol>
<h2 id="Tip-amp-Share"><a href="#Tip-amp-Share" class="headerlink" title="Tip&amp;Share"></a>Tip&amp;Share</h2><p>最近重新搭建了hexo的blog，但是hexo的操作基本都是命令行控制，导致每次hexo new post 后都要到指定目录打开md文件或者再通过vi来手动编辑。</p>
<p>然而作为一个懒人每次多开一个窗口切换然后打开文件又嫌麻烦，作为vim新手又不想调教markdown版本的vim，只好偷下懒想办法在new post的时候让系统同时打开自己习惯使用的外部编辑器了。</p>
<p>查询了一下万能的度娘/谷歌娘，结果有了:hexo自身提供了<a href="https://hexo.io/api/events#new" target="_blank" rel="noopener">new事件</a><br>的监听功能</p>
<blockquote>
<p>new</p>
<p>Emitted after a new post has been created. This event returns the post data:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;hexo.on(&apos;new&apos;, function(post)&#123;</span><br><span class="line">&gt;  //</span><br><span class="line">&gt;&#125;);</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>有了监听事件那么问题就简单了，直接监听然后node子进程exec打开文档就好了。</p>
<p>由于我自身惯用的图形编辑器是macdown，原先是准备直接<code>open macdown.app</code>但是它无法打开指定文档。</p>
<p>查了文档后发现macdown自带<a href="https://github.com/MacDownApp/macdown/wiki/Advanced-Usage" target="_blank" rel="noopener">进阶使用</a>，直接在/urs/local/bin下创建当前脚本<code>macdown</code>的软链，就可以直接通过命令打开指定文件。</p>
<p><code>$ ln -s &quot;/Applications/MacDown.app/Contents/SharedSupport/bin/macdown&quot; /usr/local/bin/macdown</code></p>
<p>准备工作完成，剩下只用在博客目录下新建scripts目录（已有无视），再在目录下建立脚本文件listen_new.js</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var exec = require(&apos;child_process&apos;).exec;</span><br><span class="line">// Hexo 3</span><br><span class="line">hexo.on(&apos;new&apos;, function(data)&#123;</span><br><span class="line">     exec(&quot;macdown &quot; + data.path);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>这之后再次新建文章是会自动在macdown中打开新生成的md文件了。</p>
]]></content>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2019/10/16/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
  </entry>
</search>
